\documentclass[main.tex]{subfiles}

\begin{document}
\kapitola{Základní syntax}

Základní syntax jazyka Rust se tolik neliší od jazyka C++. Klíčová slova \irust{for},
\irust{while}, \irust{if} apod. jsou stejná. V~této kapitole shrnu pouze základní
informace, nebudu zacházet do hloubky. Rust syntax ale nevyužívá přetěžování operátorů
do takové míry jako C++, nemělo by se tedy stát, že v~příkladech bude něco příliš
nečekaného (jako například spojování iterátorů pomocí operátoru \icpp{|} v~C++).

\sekce{Proměnné}

Na rozdíl od deklarování proměnných jejich typem (popřípadě slovem \icpp{auto}) používá
Rust klíčové slovo \irust{let}. \emph{Proměnné v~Rustu jsou defaultně konstantní}, aby
šla hodnota proměnné měnit, musíme v~deklaraci přidat klíčové slovo \irust{mut}.

Rust má i~klíčové slovo \irust{const}, které ale slouží stejnému účelu jako
\icpp{constexpr} v~jazyce C++ (deklarování compile-time konstanty).
Pokud chceme vytvořit statickou proměnnou (=globální), musíme použít klíčové slovo
\irust{static}, popřípadě \irust{static mut}. Jedním slovem není možné deklarovat více
proměnných.

Většinou je vhodné uvést při deklaraci i~počáteční hodnotu. U~\irust{let} se ale
nejedná o~chybu při kompilaci (chyba se ale objeví, pokud použíjeme neinicializovanou
proměnnou). Hodnotu přiřazujeme klasickým použitím znaku \texttt{=}.

Pokud jsme pomocí \irust{let} nadefinovali proměnnou, můžeme opětovným použitím
\irust{let} nadefinovat \emph{jinou proměnnou} se stejným názvem. Tomuto se říká stínování
(angl. shadowing). \cite[sekce\,3.1]{thebook}

V~Rustu často není potřeba udávat typ vytvářené proměnné~-- velmi dobře si umí typy
proměnných odvodit z~hodnot, popřípadě jejich dalšího používání. Toto ale platí pouze
pro deklarace pomocí slova \irust{let}~-- u~ostatních je typová anotace povinná. Pokud
si kompilátor neumí typ odvodit, je nutné typ explicitně uvést. Toho docílíme pomocí
dnes častější \uv{dvojtečkové syntaxe}. \cite[sekce\,3.2]{thebook}

Celá deklarace proměnné tedy vypadá takto:

\obrazek
\begin{rustcode}
    let mut variable_name: i32 = 5;
\end{rustcode}
\endobrl{Ukázka deklarace nekonstantní proměnné typu \irust{i32} (\icpp{int} v~C++)}
{variable declaration showcase}

\sekce{Funkce}

Stejně jako u~proměnných nezačínají deklarace funkcí jejich návratovým typem, ale
klíčovým slovem \irust{fn}. Následuje syntax velmi podobná C++, až na \uv{dvojtečkovou
    syntax} deklarace typů. Za uzavírací závorkou následuje šipka (\texttt{->}) a za ní
návratový typ. Pokud funkce nevrací nic (typ \icpp{void} v~C++), můžeme za šipku napsat
\uv{prázdný typ} \irust{()} nebo šipku vůbec nepsat.

V~Rustu je povinné zároveň s~deklarací uvést i~definici (tělo) funkce\footnote{~Pokud
    se tedy nejedná o~deklaraci funkce v~Trait definici nebo v~\irust{extern} bloku.
}. To je obsaženo ve~složených závorkách, stejně jako v~C++.

Jednou z~méně intuitivních věcí pro začátečníky jsou takzvané \uv{implicit returns}.
Pokud nedáme na konec výrazu středník, bude tento výraz vrácen jako hodnota. Toto se
používá jako vrácení úplně na posledním řádku funkce. Jinak se používá klíčové slovo
\irust{return}, stejně jako v~C++. \cite[sekce\,3.3]{thebook}

Takto by vypadala definice funkce, která sečte dvě čísla a vrátí výsledek:

\obrazek
\begin{rustcode}
    fn sum(first: &i32, second: &i32) -> i32 {
        first + second // implicit return
    }
\end{rustcode}
\endobrl{Ukázka definice funkce}{function definition showcase}

\sekce{Pattern matching}

Rust má velmi silný pattern matching. Pomocí něj je možné \uv{vytahovat} hodnoty
z~výčtů (anglicky enum), datových struktur a n-tic (anglicky tuple). Vždy je nutné použít
klíčové slovo \irust{let}. \cite[sekce\,18.1]{thebook}

\obrazek
\begin{rustcode}
    let (number, text) = (12, "Hello world!");
\end{rustcode}
\endobrl{Ukázka jednoduchého pattern matchingu}{simple pattern matching showcase}

Po tomto řádku můžeme používat proměnnou \irust{number}, která je typu \irust{i32} a
proměnnou \irust{text} typu \irust{&str} (práci s~řetězci je věnována vlastní kapitola).

Rust má také klíčové slovo \irust{match}:

\obrazek
\begin{rustcode}
    let is_two_or_three: bool = match number {
        2 | 3 => true,
        12 => false,
        _ => false,
    };
\end{rustcode}
\endobrl{Ukázka pattern matchingu pomocí \irust{match}}{match pattern matching showcase}

V tomto případě používáme \irust{match} na proměnnou \irust{number}. Pokud je hodnota
2 nebo 3, vratí \irust{match} hodnotu \irust{true}. Znak \irust{_} znamená
\uv{vše ostatní}, varianta s~hodnotou 12 je tedy zbytečná. Výsledek se zde uloží do
proměnné, v~jednotlivých ramenech (anglicky match arms) lze ale napsat libovolný kód.
Pokud \irust{match} nepočítá s~každou možností, kód se nezkompiluje.
\cite[sekce\,8.2.16]{reference}

V~tomto případě se jedná o~zbytečnou komplikaci kódu. \irust{match} a pattern matching
obecně je ale velmi užitečný pří implementování komplexnější logiky.

\sekce{Cykly a řídící bloky}

\podsekce{Cykly a řídící bloky shodné s~C++}

Klíčová slova \irust{while} a \irust{if}, \irust{else if}, \irust{else} fungují stejně
jako v~jazyce C++. Jediným rozdílem je, že závorky kolem výrazů za klíčovými slovy
nejsou povinné (a nepoužívají se).

Dalším detailem je využitelnost pattern matchingu. Ke~zjištění struktury můžeme použít
slova \irust{if let} a \irust{while let}. Pokud se match podaří, výraz vrátí
\irust{true} a proměnná je k~dispozici k~použití v~daném bloku. Toto se často vyskytuje
při práci s~možnými chybami. Následuje ukázka použítí \irust{if let} bloku. V~proměnné
\irust{calculation_result} je uložen výčet \irust{Option<i32>}~-- jedná se o~návratovou
hodnotu nějaké funkce, která \emph{může} (ale nemusí) vrátit výsledek. Pokud výsledek
existuje (proměnná má hodnotu \irust{Some}), vypíšeme jej do konzole.

\obrazek
\begin{rustcode}
    let calculation_result = Some(5);
    if let Some(num) = calculation_result {
        // print result to standard output
        println!("Success! The result is {}", num);
    } else {
        println!("Calculation not successful");
    }
\end{rustcode}
\endobrl{Ukázka \irust{if let} výrazu}{if let showcase}

\podsekce{Cyklus for}

Cyklus \irust{for} funguje jinak než v~C++. Používá se na cyklení přes tzv. iterátory.
Iterátory jako takové jsou návrhovým vzorem, který se částečně vyskytuje i~v~C++.
V~Rustu jsou ale daleko mocnější~-- jedná se o~nejpoužívanější návrhový vzor tohoto
jazyka. \uv{Klasický} cyklus for přes čísla můžeme napsat pomocí tzv. rozsahu
(anglicky range). Jeho syntax je následující:

\obrazek
\begin{rustcode}
    for i in 0..10 {
        println!("{}", i);
    }
\end{rustcode}
\endobrl{Ukázka for cyklu přes Range objekt}{for loop over range showcase}

Tato smyčka vypíše celá čísla od 0 do 9 včetně. Pokud bychom chtěli vypsat i~hodnotu 10,
museli bychom rozsah napsat takto: \irust{0..=10}. Můžeme si všimnout, že proměnná
\irust{i} se postupně nastaví na každou hodnotu iterátoru. Lze zde použít i~pattern
matching. \cite[sekce\,8.2.13]{reference}

\podsekce{Cyklus loop}

V~Rustu se nachází ještě jeden typ cyklu. Jedná se o~nekonečný cyklus, vytvořený
pomocí klíčového slova \irust{loop}. Funguje stejně jako \icpp{while (true)} v~C++.

\sekce{Makra}

Makra se syntakticky liší od C++. Mají více typů, nejčastěji se ale používají tzv.
function-like makra. Volání těchto maker vypadá stejně jako volání funkci, akorát je za
názvem znak \irust{!}. Tato makra, na rozdíl od funkcí, mohou brát libovolný počet
parametrů. Asi nejčastěji používané makro je \irust{println!}, které řeší tisknutí do
konzole bez toho, aniž bychom se museli starat o~konvertování proměnných na řetězec.

Existují také derivační a atributová makra. Derivační se používají při OOP, atributová
přidávají nějaký compile-time atribut k~symbolu (funkci, proměnné,\dots).
\cite[sekce\,19.5]{thebook}

Deklarace maker je složitější, protože pracují přímo s~abstraktním syntaktickým stromem
svého vstupu a modifikovaný strom vrací. Do vytváření maker tato práce nezachází.

\sekce{Importování}

Používání symbolů (funkcí, proměnných, objektů,~\dots) je mnohem jednodušší než v~C++.
Rust nepotřebuje znát symbol před jeho použitím (jde tedy například použít funkci, i~když
je její definice až níž v~souboru). Pro importování symbolu nám stačí použít klíčové slovo
\irust{use}, za kterým napíšeme cestu k~symbolu pomocí namespace operátorů~\irust{::}.
Nepotřebujeme žádné hlavičkové soubory, stačí nám pouze soubory s~kódem.
\cite[keyword.use]{ruststd} Při externím linkování se ale deklarováním symbolů a funkcí
bez těla nevyhneme. \cite[keyword.extern]{ruststd}

V~následujícím příkladu importujeme typ \irust{LinkedList} z~modulu \irust{collections}
knihovny \irust{std}. Dále voláme statickou metodu \irust{new} tohoto typu. Můžeme si také
všimnout, že nikde neuvádíme typ proměnné. Ukládáme do ní \uv{nový} spojový seznam~--
hlavní typ je tedy \irust{LinkedList}, ale neuvádíme ani v~něm ukládaný typ. Je totiž
odvozen z~toho, že později ukládáme do listu hodnotu typu \irust{i32}. Plný typ proměnné
\irust{list} je tedy \irust{LinkedList<i32>}.

\obrazek
\begin{rustcode}
    use std::collections::LinkedList;

    fn main() {
        let mut list = LinkedList::new();
        list.push_back(0);
    }
\end{rustcode}
\endobrl{Ukázka importování a používání namespace operátoru}{use showcase}

\sekce{Typy}

Názvy většiny základních typů se liší od těch v~C++. Jediným stejným typem je
\irust{bool}.

\podsekce{Čísla}

Rust nemá typy \icpp{short}, \icpp{long} apod. Místo toho má sadu typů začínající
na~\irust{i}. Dále následuje velikost typu v~bitech od 8 až po 128. Typy celých čísel tedy
jsou: \irust{i8}, \irust{i16}, \irust{i32}, \irust{i64} a~\irust{i128}. Pokud nám jde
pouze o~kladná čísla (\icpp{unsigned}), stačí nahradit \irust{i} za \irust{u}. Například
tedy \irust{u32}.

Výhodou tohoto způsobu je, že jsme si vždy vědomi jejich velikosti (například typ
\icpp{int} může mít různou velikost podle platformy \cite[language/types]{cppreference}).
Jejich ekvivalentem by tedy byly spíš typy jako \icpp{int32_t}, dostupné od C++11.

Pro desetinná čísla existují typy \irust{f32} a \irust{f64}. Čísla opět reprezentují
jejich velikost v~paměti. \cite[sekce\,3.2]{thebook}

\podsekce{Pole}

Pole jsou podobná objektu \icpp{std::array}. Jejich typ je \irust{[T; N]}, kde T~je typ
ukládaný v~poli a N~je délka pole. Když pole vytváříme, musíme vždy uvést počáteční
hodnotu. Do pole můžeme indexovat stejně jako v~C++ pomocí \icpp{[]}.
\cite[sekce\,3.2]{thebook}

Rust má také dynamické pole. Jeho název je z~\icpp{std::vector} zkrácen na \irust{Vec}.
Vytvářet vektory můžeme buď voláním jednoho z~konstruktorů, nebo voláním makra
\irust{vec![]}, které bere počáteční hodnoty. \cite[sekce\,8.1]{thebook}

\obrazek
\begin{rustcode}
    let mut array: [i32; 3] = [0; 3];
    array[0] = 1;
    let vector1: Vec<i32> = Vec::new();
    let vector2: Vec<i32> = Vec::with_capacity(10);
    let mut vector = vec![1, 2, 3];
    vector.push(4);
\end{rustcode}
\endobrl{Ukázka vytváření pole a vektoru}{vector and array initialization showcase}

V~ukázce nastavujeme hodnotu proměnné \irust{array} na \irust{[0; 3]}, což je pole délky~3
vyplněné nulami.

Samotný typ u~proměnné \irust{array} by šlo vynechat (byl by implicitní). U~vektorů je ale
\emph{nutné} uvést typy, protože z~konstruktoru nejde poznat, jaký typ do vektoru
ukládáme. Kdybychom je ale dále nějak používali, nebylo by nutné typ uvádět.

\podsekce{Reference}

Když chceme předat hodnotu proměnné bez jejího kopírování nebo umožnit jiné části programu
přepsat její hodnotu, použijeme reference. Rust sice má i~ukazatele, ale kvůli problémům
s~bezpečností se prakticky nepoužívají (jdou plně používat pouze v~tzv. unsafe blocích).

Stejně jako u proměnných máme dva typy referencí~-- \irust{&T} a \irust{&mut T} (kde T je
typ proměné). \irust{&T} nám neumožňuje jakkoliv modifikovat proměnnou na kterou ukazuje.
Když chceme poslat referenci, musíme to explicitně uvést (viz ukázka níže). Reference
umožňující modifikaci jdou dělat pouze na modifikovatelné proměnné.
\cite[sekce\,4.2]{thebook}

Pokud chceme referenci na blok paměti, pošleme tzv. řez (anglicky slice). Jedná se
o~speciální objekt, který si pamatuje ukazatel na začátek a délku úseku. Jeho zápis je
\irust{&[T]} a \irust{&mut [T]}. Získáme jej pomocí operátoru \irust{[]}, ve kterém ale
neuvedeme index, ale rozsah. \cite[sekce\,4.3]{thebook}

\obrazek
\begin{rustcode}
    fn change_number(number: &mut u64) {
        *number = 0;
    }

    fn main() {
        let mut number = 5;
        change_number(&mut number);
        println!("{}", number); // 0
        let mut vector = vec![1, 2, 3];
        let number_slice: &mut [i32] = &mut vector[1..];
        number_slice[1] = 0;
        println!("{}", vector[2]); // 0
    }
\end{rustcode}
\endobrl{Ukázka použití referencí a řezů}{references showcase}

V~ukázce vytváříme modifikovatelnou proměnnou \irust{number}, posíláme její referenci
funkci, ta změní její hodnotu na 0. Následně tiskneme hodnotu proměnné do \irust{stdout}.
Typ proměnné je \irust{u64}. Explicitně jsme jej neuvedli, ale kompilátor si to odvodil
z~toho, že referenci na proměnnou posíláme funkci, která bere referenci na \irust{u64}.

Dále vytváříme vektor o~třech prvcích. Referenci na všechny \emph{stávající}\footnote{~
    Kdybychom do vektoru poté přidali nový prvek, řez by měl stále délku~2.
} prvky vektoru s~indexem~1 a dále ukládáme do proměnné \irust{number_slice}. Používáme
\irust{1..}~-- zprava nekonečný rozsah (když neuvedeme jeden krajní prvek, bude rozsah tím
směrem zasahovat do nekonečna). Měníme druhý prvek řezu (tedy třetí prvek vektoru), ten
následně tiskneme (pomocí vektoru, ne řezu).

\podsekce{Řetězce}

Situace s~řetězci je dost podobná C++. Existují dva typy: \irust{&str} a \irust{String}.
Protože Rust používá UTF-8, velikost typu \irust{char} jsou 4\,bajty.
\cite[primitive.char]{ruststd} Pokud chceme typ reprezentující jeden bajt (a tedy i~paměť
do které se řetězce ukládají), použijeme \irust{u8}. Pokud chceme používat ASCII, můžeme
používat \uv{bajtový řetězec} (\irust{b""}). Jeho znaky můžeme psát jako \irust{b'a'}
apod. \cite[sekce\,19.3]{byexample}

\irust{&str} je reference na konstantní řetězec, podobně jako \icpp{const char *}.
Na~pozadí se jedná o~\irust{&[u8]}, kde je vždy uložena \emph{validní} UTF-8 sekvence.

\irust{String}, stejně jako \icpp{std::string} je dynamicky alokovaný řetězec. Funguje
stejně jako v~C++, akorát jeho buffer je \irust{Vec<u8>} (tj. dynamické pole bajtů) a jeho
velikost je 24\,bajtů (nikoliv 32). \cite[sekce\,8.2]{thebook}

Vytvářet řetězce můžeme více způsoby:

\obrazek
\begin{rustcode}
    let hello1: &str = "Hello world!";
    let hello2: String = "Hello world!".to_string();
    let hello3: String = String::from("Hello world!");
\end{rustcode}
\endobrl{Ukázka vytváření řetězců}{string initialization showcase}

\podsekce{Vlastní typy}

Podobně jako C++, Rust má klíčové slovo \irust{struct}, které umožňuje vytvářet vlastní
typy. Ve složených závorkách se nachází \emph{pouze členské proměnné} oddělené čárkami.
\cite[sekce\,5.1]{thebook}

Příklad struktury \irust{Person}:

\obrazek
\begin{rustcode}
    struct Person {
        name: String,
        age: u8,
    }
\end{rustcode}
\endobrl{Ukázka vytvoření struktury}{struct showcase}

Pokud chceme přidat metody, uděláme tak v~tzv. \irust{impl} bloku. Můžeme zde vytvářet
funkce, které jako první parametr berou \irust{self}, \irust{&self} nebo
\irust{&mut self}. Abychom měli přistup k~datům ve~struktuře, musíme to udělat právě přes
jednu z~těchto možností. Pokud funkce nebere žádnou z~nich, jedná se
o~\uv{statickou metodu}\footnote{~Všechny funkce nadefinované v~\irust{impl} bloku
    se nazývají \emph{asociované funkce} (asociované s~typem). Protože první parametr
    takové asociované funkce není \irust{self}, nejedná se o~metodu.
}. Když použijeme přímo \irust{self}, ztratí volající přístup k~objektu (Rust implicitně
nekopíruje, ale přesunuje hodnoty). \cite[sekce\,5.3]{thebook}

Nemáme speciální syntax pro konstruktor. Místo toho existuje konvence, že každá struktura
má statickou metodu \irust{new}, která vrací vytvořenou strukturu.

Příklad funkcí na struktuře \irust{Person}:

\obrazek
\begin{rustcode}
    impl Person {
        fn new(name: &str, age: u8) -> Person {
            Person {
                name: name.to_string(),
                age, // equivalent to `age: age`
            }
        }

        fn add_year(&mut self) {
            self.age += 1;
        }
    }
\end{rustcode}
\endobrl{Ukázka \irust{impl} bloku}{struct impl showcase}

Rust má také výčty. Oproti C++ ale mohou držet i~další hodnoty, a to buď jako n-tici, nebo
jako strukturu. Můžeme jim také přidávat asociované funkce pomocí \irust{impl} bloků.
\cite[sekce\,6.1]{thebook} Příklad na obr.\,\ref{enum showcase}.

\obrazek
\begin{rustcode}
    enum FileError {
        // An `enum` variant may either be `unit-like`,
        NotFound,
        // like tuple structs,
        TooBig(u64),
        // or c-like structures.
        DifferentOwner { user: String },
    }

    impl FileError {
        fn description(&self) -> String {
            match self {
                FileError::NotFound => "File not found".to_string(),
                FileError::TooBig(max_size) => {
                    format!("File too big, max size is {}", max_size)
                }
                FileError::DifferentOwner { user } => {
                    format!("Different owner: {}", user)
                }
            }
        }
    }
\end{rustcode}
\endobrl{Ukázka výčtů}{enum showcase}

\sekce{Generické bloky}

Na spoustě míst lze použít generiky~-- kompilátor dosadí přesný typ až při kompilaci,
stejně jako v~C++. Používání generik je poněkud jednodušší (není potřeba psát
\icpp{template<typename T>}, ale na správném místě stačí pouze \irust{<T>}), zato ale
častěji a komplikovaněji používané. Ke generikám můžeme (a většinou musíme) přidat i~tzv.
trait bound~-- typ~T musí implementovat určitý trait (popř. jejich kombinaci), tj. musí
mít určitou funkcionalitu. Více v~kapitole o~OOP.

\sekce{Move sémantika}

Když v~C++ nebereme proměnou přes referenci, její hodnota se zkopíruje. V~Rustu tomu tak
není. Používá totiž tzv. move sémantiku, tj. hodnota se \uv{přesune} do volané funkce a
dále k~ní nejde přistupovat. Pokud se jedná o~primitiv (například číslo), hodnota se
kopíruje (protože kopie je triviální)~-- toto tedy platí pouze pro komplexnější typy.
Viz obr.\,\ref{move semantics showcase}. \cite[sekce\,15.2]{byexample}

\obrazek
\begin{rustcode*}{highlightlines={3-3},highlightcolor=m-hi-error}
    let a = vec![1, 2, 3];
    let b: Vec<i32> = a; // move `a` into `b`
    for elem in a {
        println!("{}", elem);
    }
\end{rustcode*}
\newline
\vlozobr{images/move-compile-error.png}{0.36}
\endobrl{Ukázka move sémantiky}{move semantics showcase}
\end{document}
