\documentclass[main.tex]{subfiles}

\begin{document}
\kapitola{Základní syntax}

Základní syntax jazyka Rust se tolik neliší od jazyka C++. Klíčová slova \irust{for},
\irust{while}, \irust{if} apod. jsou stejná. V~této kapitole shrnu pouze základní
informace, nebudu zacházet do hloubky. Rust syntax ale nevyužívá přetěžování operátorů
do takové míry jako C++, nemělo by se tedy stát, že v~příkladech bude něco příliš
nečekaného (jako například spojování iterátorů pomocí operátoru \icpp{|} v~C++).

\sekce{Proměnné}

Na rozdíl od deklarování proměnných jejich typem (popřípadě slovem \icpp{auto}) používá
Rust klíčové slovo \irust{let}. \emph{Proměnné v~Rustu jsou defaultně konstantní}, aby
šla hodnota proměnné měnit, musíme v~deklaraci přidat klíčové slovo \irust{mut}.

Rust má i~klíčové slovo \irust{const}, které ale slouží stejnému účelu jako
\icpp{constexpr} v~jazyce C++ (deklarování compile-time konstanty).
Pokud chceme vytvořit statickou proměnnou (=globální), musíme použít klíčové slovo
\irust{static}, popřípadě \irust{static mut}. Jedním slovem není možné deklarovat více
proměnných.

Většinou je vhodné uvést při deklaraci i~počáteční hodnotu. U~\irust{let} se ale
nejedná o~error při kompilaci (error se ale objeví, pokud použíjeme neinicializovanou
proměnnou). Hodnotu přiřazujeme klasickým použitím znaku \texttt{=}.

V~Rustu často není potřeba udávat typ vytvářené proměnné -- velmi dobře si umí typy
proměnných odvodit z~hodnot, popřípadě jejich dalšího používání. Toto ale platí pouze
pro deklarace pomocí slova \irust{let} -- u~ostatních je typová anotace povinná. Pokud
si kompilátor neumí typ odvodit, je nutné typ explicitně uvést. Toho docílíme pomocí
dnes častějšího \uv{dvojtečkového syntaxu}. Celá deklarace proměnné tedy vypadá takto:

\obrazek
\rustfile[firstline=5,lastline=5]{../rust/examples/src/main.rs}
\endobrl{Ukázka deklarace nekonstantní proměnné typu \irust{i32} (\icpp{int} v~C++)}
{variable declaration showcase}

\sekce{Funkce}

Stejně jako u~proměnných nezačínají deklarace funkcí jejich návratovým typem, ale
klíčovým slovem \irust{fn}. Následuje syntax velmi podobný C++, až na \uv{dvojtečkový
    syntax} deklarace typů. Za uzavírací závorkou následuje šipka (\texttt{->}) a za ní
návratový typ. Pokud funkce nevrací nic (typ \icpp{void} v~C++), můžeme za šipku napsat
\uv{prázdný typ} \irust{()} nebo šipku vůbec nepsat.

V~Rustu je povinné zároveň s~deklarací uvést i~definici (tělo) funkce\footnote{Pokud
    se tedy nejedná o~deklaraci funkce v~Trait definici nebo v~\irust{extern} bloku.
} To je obsaženo ve~složených závorkách, stejně jako v~C++.

Jednou z~méně intuitivních věcí pro začátečníky jsou takzvané \uv{implicit returns}.
Pokud nedáme na konec výrazu středník, bude tento výraz vrácen jako hodnota. Toto se
používá hlavně pro malé funkce s~jednoduchou logikou nebo jako vrácení úplně na posledním
řádku funkce. Jinak se většinou používá klíčové slovo \irust{return}, stejně jako v~C++.
Takto by vypadala definice funkce, která sečte dvě čísla a vrátí výsledek:

\obrazek
\rustfile[firstline=9,lastline=11]{../rust/examples/src/main.rs}
\endobrl{Ukázka definice funkce}{function definition showcase}

\sekce{Pattern matching}

Rust má velmi silný pattern matching. Pomocí něj je možné \uv{vytahovat} hodnoty
z~enumů, datových struktur a n-tic (anglicky tuple). Vždy je nutné použít klíčové
slovo \irust{let}.

\obrazek
\rustfile[firstline=15,lastline=15]{../rust/examples/src/main.rs}
\endobrl{Ukázka jednoduchého pattern matchingu}{simple pattern matching showcase}

Po tomto řádku můžeme používat proměnnou \irust{number}, která je typu \irust{i32} a
proměnnou \irust{text} typu \irust{&str} (práci se stringy je věnována vlastní kapitola).

Rust má také klíčové slovo \irust{match}:

\obrazek
\rustfile[firstline=19,lastline=23]{../rust/examples/src/main.rs}
\endobrl{Ukázka pattern matchingu pomocí \irust{match}}{match pattern matching showcase}

V tomto případě používáme \irust{match} na proměnnou \irust{number}. Pokud je hodnota
2 nebo 3, vratí \irust{match} hodnotu \irust{true}. Znak \irust{_} znamená
\uv{vše ostatní}, rameno s~hodnotou 12 je tedy zbytečné. Výsledek se zde uloží do
proměnné, v~jednotlivých ramenech (anglicky match arms) lze ale napsat libovolný kód.
Pokud \irust{match} nepočítá s~každou možností, kód se nezkompiluje.

V~tomto případě se jedná o~zbytečnou komplikaci kódu. \irust{match} a pattern matching
obecně je ale velmi užitečný pří implementování komplexnější logiky.

\sekce{Smyčky a kontrolní bloky}

\podsekce{Smyčky a kontrolní bloky shodné s~C++}

Klíčová slova \irust{while} a \irust{if}, \irust{else if}, \irust{else} fungují stejně
jako v~jazyce C++. Jediným rozdílem je, že závorky kolem výrazů za klíčovými slovy
nejsou povinné (a nepoužívají se).

Dalším detailem je využitelnost pattern matchingu. Ke~zjištění struktury můžeme použít
slova \irust{if let} a \irust{while let}. Pokud se match podaří, výraz vrátí
\irust{true} a proměnná je k~dispozici k~použití v~daném bloku. Toto se často vyskytuje
při práci s~možnými errory. Následuje ukázka použítí \irust{if let} bloku. V~proměnné
\irust{calculation_result} je uložen enum \irust{Option<i32>} -- jedná se o~návratovou
hodnotu nějaké funkce, která \emph{může} (ale nemusí) vrátit výsledek. Pokud výsledek
existuje (proměnná má hodnotu \irust{Some}), vypíšeme jej do konzole.

\obrazek
\rustfile[firstline=27,lastline=33]{../rust/examples/src/main.rs}
\endobrl{Ukázka \irust{if let} výrazu}{if let showcase}

\podsekce{Smyčka for}

Smyčka \irust{for} funguje jinak než v~C++. Používá se na cyklení přes tzv. iterátory.
Iterátory jako takové jsou návrhovým vzorem, který se částečně vyskytuje i~v~C++.
V~Rustu jsou ale daleko mocnější -- jedná se o~nejpoužívanější návrhový vzor tohoto
jazyka. \uv{Klasický} for loop přes čísla můžeme napsat pomocí tzv. rozsahu
(anglicky range). Jeho syntax je následující:

\obrazek
\rustfile[firstline=37,lastline=39]{../rust/examples/src/main.rs}
\endobrl{Ukázka for smyčky přes Range objekt}{for loop over range showcase}

Tato smyčka vypíše celá čísla od 0 do 9 včetně. Pokud bychom chtěli vypsat i~hodnotu 10,
museli bychom range napsat takto: \irust{0..=10}. Můžeme si všimnout, že proměnná
\irust{i} se postupně nastaví na každou hodnotu iterátoru. Lze zde použít i~pattern
matching.

\podsekce{smyčka loop}

V~Rustu se nachází ještě jeden typ smyčky. Jedná se o~nekonečnou smyčku, vytvořenou
pomocí klíčového slova \irust{loop}. Funguje stejně jako \icpp{while (true)} v~C++.

\sekce{Makra}

Makra se syntakticky liší od C++. Mají více typů, nejčastěji se ale používají tzv.
function-like makra. Volání těchto maker vypadá stejně jako volání funkci, akorát je za
názvem znak \irust{!}. Tato makra, na rozdíl od funkcí, mohou brát libovolný počet
parametrů. Asi nejčastěji používané makro je \irust{println!}, které řeší tisknutí do
konzole bez toho, aniž bychom se museli starat o~konvertování proměnných na řetězec.

Deklarace maker je složitější, protože pracují přímo s~abstraktním syntaktickým stromem
svého vstupu a modifikovaný strom vrací. Do vytváření maker tato práce nezachází.

\sekce{Importování}

Používání symbolů (funkcí, proměnných, objektů,~\dots) je mnohem jednodušší než v~C++.
Rust nepotřebuje znát symbol před jeho použitím (jde tedy například použít funkci, i~když
je její definice až níž v~souboru). Pro importování symbolu nám stačí použít klíčové slovo
\irust{use}, za kterým napíšeme cestu k~symbolu pomocí namespace operátorů~\irust{::}.
Nepotřebujeme žádné hlavičkové soubory, stačí nám pouze soubory s~kódem. Při externím
linkování se ale deklarováním symbolů a funkcí bez těla nevyhneme.

V~následujícím příkladu importujeme typ \irust{LinkedList} z~modulu \irust{collections}
knihovny \irust{std}. Dále voláme statickou metodu \irust{new} tohoto typu.

\obrazek
\rustfile[firstline=43,lastline=48]{../rust/examples/src/main.rs}
\endobrl{Ukázka importování a používání namespace operátoru}{use showcase}

\sekce{Typy}

Názvy většiny základních typů se liší od těch v~C++. Jediným stejným typem je
\irust{bool}.

\podsekce{Čísla}

Rust nemá typy \icpp{short}, \icpp{long} apod. Místo toho má sadu typů začínající
na~\irust{i}. Dále následuje velikost typu v~bitech od 8 až po 128. Typy celých čísel tedy
jsou: \irust{i8}, \irust{i16}, \irust{i32}, \irust{i64} a~\irust{i128}. Pokud nám jde
pouze o~kladná čísla (\icpp{unsigned}), stačí nahradit \irust{i} za \irust{u}. Například
tedy \irust{u32}.

Výhodou tohoto způsobu je, že jsme si vždy vědomi jejich velikosti (například typ
\icpp{int} může mít různou velikost podle platformy). Jejich ekvivalentem by tedy byly
spíš typy jako \icpp{int32_t}, dostupné od C++11.

Pro desetinná čísla existují typy \irust{f32} a \irust{f64}. Čísla opět reprezentují
jejich velikost v~paměti.

\podsekce{Pole}

Pole jsou podobná objektu \icpp{std::array}. Jejich typ je \irust{[T; N]}, kde T~je typ
ukládaný v~poli a N~je délka pole.

Pokud je chceme poslat do funkce jako ukazatel, pošleme tzv. řez (anglicky slice). Jedná
se o speciální objekt, který si pamatuje ukazatel na začátek a délku úseku.

\podsekce{Řetězce}

Situace s~řetězci je dost podobná C++. Existují dva typy: \irust{&str} a \irust{String}.
Protože Rust používá UTF-8, velikost typu \irust{char} jsou 4\,byty. Pokud chceme typ
reprezentující jeden byte (a tedy i~paměť do které se řetězce ukládají), použijeme
\irust{u8}.

\irust{&str} je reference na konstantní řetězec, podobně jako \icpp{const char *}.
Na~pozadí se jedná o~\irust{&[u8]}, kde je vždy uložena \emph{validní} UTF-8 sekvence.

\irust{String}, stejně jako \icpp{std::string} je dynamicky alokovaný řetězec. Funguje
stejně jako v~C++, akorát jeho buffer je \irust{Vec<u8>} (tj. dynamické pole bytů).

Vytvářet řetězce můžeme více způsoby:

\obrazek
\rustfile[firstline=52,lastline=54]{../rust/examples/src/main.rs}
\endobrl{Ukázka vytváření řetězců}{string initialization showcase}

\podsekce{Vlastní typy}

\podsekce{Ukazatele a reference}

% TODO: poznámka o generikách

\end{document}
